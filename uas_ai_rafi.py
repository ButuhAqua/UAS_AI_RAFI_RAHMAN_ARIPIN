# -*- coding: utf-8 -*-
"""UAS_AI_RAFI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uaCdgeF8iqLURjnNKhiu8UG0hBzoMBgM
"""

# LANGKAH 1: PREPROCESSING DATA (Versi Diperbaiki)

import pandas as pd
from sklearn.preprocessing import LabelEncoder

# 1. Membaca dataset yang telah diunggah ulang
file_path = "/mnt/data/netflix_titles.csv"
df = pd.read_csv(file_path)

# 2. Menghapus kolom yang tidak relevan
df_cleaned = df.drop(columns=['description', 'show_id', 'title'])

# 3. Menangani missing value
df_cleaned['country'].fillna("Unknown", inplace=True)
df_cleaned['director'].fillna("Unknown", inplace=True)
df_cleaned['cast'].fillna("Unknown", inplace=True)

# Menghapus baris dengan missing value pada 'rating', 'duration', dan 'date_added'
df_cleaned.dropna(subset=['rating', 'duration', 'date_added'], inplace=True)

# 4. Membersihkan data dan mengubah format
# Menghilangkan spasi ekstra di 'date_added' lalu mengonversinya ke datetime
df_cleaned['date_added'] = df_cleaned['date_added'].astype(str).str.strip()
df_cleaned['date_added'] = pd.to_datetime(df_cleaned['date_added'], errors='coerce')

# Mengonversi durasi ke angka (menit)
def convert_duration(value):
    if 'min' in value:
        return int(value.split()[0])  # Mengambil angka sebelum "min"
    elif 'Season' in value:
        return int(value.split()[0]) * 60  # Mengasumsikan 1 season = 60 menit
    else:
        return 0  # Jika tidak ada format yang dikenali, anggap sebagai 0

df_cleaned['duration'] = df_cleaned['duration'].apply(convert_duration)

# 5. Encoding data kategori ke angka
label_encoders = {}
for col in ['type', 'rating', 'country']:
    le = LabelEncoder()
    df_cleaned[col] = le.fit_transform(df_cleaned[col])
    label_encoders[col] = le

# Menampilkan hasil akhir preprocessing
df_cleaned.head()

# LANGKAH 2: CLUSTERING DENGAN K-MEANS (FINAL TANPA ERROR UNTUK GOOGLE COLAB)

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.cluster import KMeans

# 1. Membaca ulang dataset dan melakukan preprocessing ulang agar tidak ada kesalahan
file_path = "/mnt/data/netflix_titles.csv"
df = pd.read_csv(file_path)

# Menghapus kolom yang tidak relevan
df_cleaned = df.drop(columns=['description', 'show_id', 'title'])

# Menangani missing value
df_cleaned['country'].fillna("Unknown", inplace=True)
df_cleaned['director'].fillna("Unknown", inplace=True)
df_cleaned['cast'].fillna("Unknown", inplace=True)

# Menghapus baris dengan missing value pada 'rating', 'duration', dan 'date_added'
df_cleaned.dropna(subset=['rating', 'duration', 'date_added'], inplace=True)

# Menghilangkan spasi ekstra di 'date_added' lalu mengonversinya ke datetime
df_cleaned['date_added'] = df_cleaned['date_added'].astype(str).str.strip()
df_cleaned['date_added'] = pd.to_datetime(df_cleaned['date_added'], errors='coerce')

# Mengonversi durasi ke angka (menit)
def convert_duration(value):
    if 'min' in value:
        return int(value.split()[0])  # Mengambil angka sebelum "min"
    elif 'Season' in value:
        return int(value.split()[0]) * 60  # Mengasumsikan 1 season = 60 menit
    else:
        return 0  # Jika tidak ada format yang dikenali, anggap sebagai 0

df_cleaned['duration'] = df_cleaned['duration'].apply(convert_duration)

# Encoding data kategori ke angka
label_encoders = {}
for col in ['type', 'rating', 'country']:
    le = LabelEncoder()
    df_cleaned[col] = le.fit_transform(df_cleaned[col])
    label_encoders[col] = le

# 2. Menentukan jumlah klaster (K) menggunakan Metode Elbow
features = ['type', 'country', 'release_year', 'rating', 'duration']
X = df_cleaned[features]

wcss = []
K_range = range(1, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42, n_init=10)
    kmeans.fit(X)
    wcss.append(kmeans.inertia_)  # Menyimpan nilai WCSS

# Menampilkan grafik Elbow untuk menentukan jumlah klaster yang optimal
plt.figure(figsize=(8, 5))
plt.plot(K_range, wcss, marker='o', linestyle='-')
plt.xlabel("Jumlah Klaster (K)")
plt.ylabel("WCSS (Within-Cluster Sum of Squares)")
plt.title("Metode Elbow untuk Menentukan K Optimal")
plt.show()

# 3. Menentukan jumlah klaster berdasarkan grafik Elbow
# Dari grafik elbow, kita umumnya memilih titik "siku". Biasanya sekitar K=4
optimal_k = 4  # Bisa disesuaikan berdasarkan hasil grafik

# 4. Menjalankan algoritma clustering dengan K-Means
kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
df_cleaned['cluster'] = kmeans.fit_predict(X)

# 5. Menampilkan jumlah data di tiap klaster
cluster_counts = df_cleaned['cluster'].value_counts()

# Menampilkan hasil clustering langsung di output (tanpa ace_tools)
print("\nHasil Clustering:")
display(df_cleaned.head())

# Menampilkan jumlah data per klaster
print("\nJumlah Data per Klaster:")
print(cluster_counts)

# Menyimpan hasil clustering ke dalam file CSV agar bisa diunduh
hasil_clustering_path = "/mnt/data/hasil_clustering.csv"
df_cleaned.to_csv(hasil_clustering_path, index=False)

# Menampilkan lokasi file CSV agar bisa diunduh
print("\nHasil clustering telah disimpan ke:", hasil_clustering_path)

# LANGKAH 3: PENGGABUNGAN DENGAN MACHINE LEARNING (LINEAR REGRESSION) + VISUALISASI

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.cluster import KMeans

# 1. Membaca ulang dataset dan melakukan preprocessing ulang agar tidak ada kesalahan
file_path = "/mnt/data/netflix_titles.csv"
df = pd.read_csv(file_path)

# Menghapus kolom yang tidak relevan
df_cleaned = df.drop(columns=['description', 'show_id', 'title'])

# Menangani missing value
df_cleaned['country'].fillna("Unknown", inplace=True)
df_cleaned['director'].fillna("Unknown", inplace=True)
df_cleaned['cast'].fillna("Unknown", inplace=True)

# Menghapus baris dengan missing value pada 'rating', 'duration', dan 'date_added'
df_cleaned.dropna(subset=['rating', 'duration', 'date_added'], inplace=True)

# Menghilangkan spasi ekstra di 'date_added' lalu mengonversinya ke datetime
df_cleaned['date_added'] = df_cleaned['date_added'].astype(str).str.strip()
df_cleaned['date_added'] = pd.to_datetime(df_cleaned['date_added'], errors='coerce')

# Mengonversi durasi ke angka (menit)
def convert_duration(value):
    if 'min' in value:
        return int(value.split()[0])  # Mengambil angka sebelum "min"
    elif 'Season' in value:
        return int(value.split()[0]) * 60  # Mengasumsikan 1 season = 60 menit
    else:
        return 0  # Jika tidak ada format yang dikenali, anggap sebagai 0

df_cleaned['duration'] = df_cleaned['duration'].apply(convert_duration)

# Encoding data kategori ke angka
label_encoders = {}
for col in ['type', 'rating', 'country']:
    le = LabelEncoder()
    df_cleaned[col] = le.fit_transform(df_cleaned[col])
    label_encoders[col] = le

# 2. Menentukan jumlah klaster (K) menggunakan Metode Elbow
features = ['type', 'country', 'release_year', 'rating', 'duration']
X_clustering = df_cleaned[features]

# Menjalankan K-Means dengan jumlah klaster optimal (misal K=4 berdasarkan elbow method)
optimal_k = 4
kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
df_cleaned['cluster'] = kmeans.fit_predict(X_clustering)

# 3. Menggunakan hasil klaster sebagai fitur tambahan untuk prediksi durasi tayangan
features_ml = ['type', 'country', 'release_year', 'rating', 'cluster']
X = df_cleaned[features_ml]
y = df_cleaned['duration']  # Target: Durasi tayangan dalam menit

# 4. Membagi data menjadi training dan testing (80% train, 20% test)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Melatih model Linear Regression
model = LinearRegression()
model.fit(X_train, y_train)

# 5. Evaluasi kinerja model
y_pred = model.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

# Menampilkan hasil evaluasi
print("\nðŸ“Š Evaluasi Model Linear Regression:")
print(f"MAE (Mean Absolute Error): {mae:.2f}")
print(f"MSE (Mean Squared Error): {mse:.2f}")
print(f"RMSE (Root Mean Squared Error): {rmse:.2f}")
print(f"RÂ² Score: {r2:.4f}")

# VISUALISASI HASIL PREDIKSI VS NILAI SEBENARNYA
plt.figure(figsize=(8, 5))
plt.scatter(y_test, y_pred, alpha=0.5, edgecolors='k', label="Prediksi")
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], '--', color='red', lw=2, label="Ideal")
plt.xlabel("Durasi Sebenarnya (menit)")
plt.ylabel("Durasi yang Diprediksi (menit)")
plt.title("Visualisasi Prediksi vs Nilai Sebenarnya")
plt.legend()
plt.show()

# LANGKAH 4: EVALUASI DAN PENGOPTIMALAN

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LinearRegression, Ridge
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.pipeline import Pipeline
from sklearn.cluster import KMeans

# 1. Membaca ulang dataset dan melakukan preprocessing ulang agar tidak ada kesalahan
file_path = "/mnt/data/netflix_titles.csv"
df = pd.read_csv(file_path)

# Menghapus kolom yang tidak relevan
df_cleaned = df.drop(columns=['description', 'show_id', 'title'])

# Menangani missing value
df_cleaned['country'].fillna("Unknown", inplace=True)
df_cleaned['director'].fillna("Unknown", inplace=True)
df_cleaned['cast'].fillna("Unknown", inplace=True)

# Menghapus baris dengan missing value pada 'rating', 'duration', dan 'date_added'
df_cleaned.dropna(subset=['rating', 'duration', 'date_added'], inplace=True)

# Menghilangkan spasi ekstra di 'date_added' lalu mengonversinya ke datetime
df_cleaned['date_added'] = df_cleaned['date_added'].astype(str).str.strip()
df_cleaned['date_added'] = pd.to_datetime(df_cleaned['date_added'], errors='coerce')

# Mengonversi durasi ke angka (menit)
def convert_duration(value):
    if 'min' in value:
        return int(value.split()[0])  # Mengambil angka sebelum "min"
    elif 'Season' in value:
        return int(value.split()[0]) * 60  # Mengasumsikan 1 season = 60 menit
    else:
        return 0  # Jika tidak ada format yang dikenali, anggap sebagai 0

df_cleaned['duration'] = df_cleaned['duration'].apply(convert_duration)

# Encoding data kategori ke angka
label_encoders = {}
for col in ['type', 'rating', 'country']:
    le = LabelEncoder()
    df_cleaned[col] = le.fit_transform(df_cleaned[col])
    label_encoders[col] = le

# 2. Menentukan jumlah klaster (K) menggunakan K-Means
features = ['type', 'country', 'release_year', 'rating', 'duration']
X_clustering = df_cleaned[features]

optimal_k = 4  # Berdasarkan elbow method
kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
df_cleaned['cluster'] = kmeans.fit_predict(X_clustering)

# 3. Menggunakan hasil klaster sebagai fitur tambahan
features_ml = ['type', 'country', 'release_year', 'rating', 'cluster']
X = df_cleaned[features_ml]
y = df_cleaned['duration']

# Membagi data menjadi training dan testing
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 4. Melatih model Linear Regression (sebelum optimasi)
model = LinearRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

mae = mean_absolute_error(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

# 5. Pengoptimalan Hyperparameter dengan Ridge Regression (Regularisasi)
pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('ridge', Ridge())
])

param_grid = {'ridge__alpha': [0.1, 1.0, 10.0, 100.0]}
grid_search = GridSearchCV(pipeline, param_grid, cv=5, scoring='r2')
grid_search.fit(X_train, y_train)

# Model terbaik dari Grid Search
best_model = grid_search.best_estimator_
y_pred_best = best_model.predict(X_test)

mae_best = mean_absolute_error(y_test, y_pred_best)
mse_best = mean_squared_error(y_test, y_pred_best)
rmse_best = np.sqrt(mse_best)
r2_best = r2_score(y_test, y_pred_best)

# 6. Bandingkan hasil dengan model tanpa clustering
features_no_cluster = ['type', 'country', 'release_year', 'rating']
X_no_cluster = df_cleaned[features_no_cluster]

# Membagi data menjadi training dan testing untuk model tanpa clustering
X_train_nc, X_test_nc, y_train_nc, y_test_nc = train_test_split(X_no_cluster, y, test_size=0.2, random_state=42)

# Melatih model Linear Regression tanpa clustering
model_nc = LinearRegression()
model_nc.fit(X_train_nc, y_train_nc)
y_pred_nc = model_nc.predict(X_test_nc)

# Evaluasi model tanpa clustering
mae_nc = mean_absolute_error(y_test_nc, y_pred_nc)
mse_nc = mean_squared_error(y_test_nc, y_pred_nc)
rmse_nc = np.sqrt(mse_nc)
r2_nc = r2_score(y_test_nc, y_pred_nc)

# 7. Menampilkan perbandingan hasil dengan model tanpa clustering
print("\nðŸ“Š Perbandingan Model:")
print(f"{'Metric':<20} {'Linear Regression':<20} {'Optimized Ridge':<20} {'Without Clustering':<20}")
print("-" * 80)
print(f"{'MAE':<20} {mae:.2f} {mae_best:.2f} {mae_nc:.2f}")
print(f"{'MSE':<20} {mse:.2f} {mse_best:.2f} {mse_nc:.2f}")
print(f"{'RMSE':<20} {rmse:.2f} {rmse_best:.2f} {rmse_nc:.2f}")
print(f"{'RÂ² Score':<20} {r2:.4f} {r2_best:.4f} {r2_nc:.4f}")

# 8. Visualisasi Perbandingan Model dengan dan tanpa Clustering
plt.figure(figsize=(8, 5))
models = ['Linear Regression', 'Optimized Ridge', 'Without Clustering']
r2_scores = [r2, r2_best, r2_nc]

plt.bar(models, r2_scores, color=['blue', 'green', 'red'])
plt.xlabel("Model")
plt.ylabel("RÂ² Score")
plt.title("Perbandingan RÂ² Score antara Model dengan dan tanpa Clustering")
plt.ylim(0, 1)
plt.show()

# MEMUAT ULANG DATA DAN MELAKUKAN PEMROSESAN ULANG

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.linear_model import LinearRegression, Ridge
from sklearn.pipeline import Pipeline
from sklearn.cluster import KMeans
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# 1. Membaca dataset terbaru
file_path = "/mnt/data/netflix_titles.csv"
df = pd.read_csv(file_path)

# Menghapus kolom yang tidak relevan
df_cleaned = df.drop(columns=['description', 'show_id', 'title'])

# Menangani missing value
df_cleaned['country'].fillna("Unknown", inplace=True)
df_cleaned['director'].fillna("Unknown", inplace=True)
df_cleaned['cast'].fillna("Unknown", inplace=True)

# Menghapus baris dengan missing value pada 'rating', 'duration', dan 'date_added'
df_cleaned.dropna(subset=['rating', 'duration', 'date_added'], inplace=True)

# Menghilangkan spasi ekstra di 'date_added' lalu mengonversinya ke datetime
df_cleaned['date_added'] = df_cleaned['date_added'].astype(str).str.strip()
df_cleaned['date_added'] = pd.to_datetime(df_cleaned['date_added'], errors='coerce')

# Mengonversi durasi ke angka (menit)
def convert_duration(value):
    if 'min' in value:
        return int(value.split()[0])  # Mengambil angka sebelum "min"
    elif 'Season' in value:
        return int(value.split()[0]) * 60  # Mengasumsikan 1 season = 60 menit
    else:
        return 0  # Jika tidak ada format yang dikenali, anggap sebagai 0

df_cleaned['duration'] = df_cleaned['duration'].apply(convert_duration)

# Encoding data kategori ke angka
label_encoders = {}
for col in ['type', 'rating', 'country']:
    le = LabelEncoder()
    df_cleaned[col] = le.fit_transform(df_cleaned[col])
    label_encoders[col] = le

# 2. Menjalankan clustering dengan K-Means
features = ['type', 'country', 'release_year', 'rating', 'duration']
X_clustering = df_cleaned[features]

optimal_k = 4  # Berdasarkan elbow method
kmeans = KMeans(n_clusters=optimal_k, random_state=42, n_init=10)
df_cleaned['cluster'] = kmeans.fit_predict(X_clustering)

# 3. Model dengan clustering
features_with_cluster = ['type', 'country', 'release_year', 'rating', 'cluster']
X_cluster = df_cleaned[features_with_cluster]
y = df_cleaned['duration']

X_train_c, X_test_c, y_train_c, y_test_c = train_test_split(X_cluster, y, test_size=0.2, random_state=42)

model_c = LinearRegression()
model_c.fit(X_train_c, y_train_c)
y_pred_c = model_c.predict(X_test_c)

# Evaluasi model dengan clustering
mae_c = mean_absolute_error(y_test_c, y_pred_c)
mse_c = mean_squared_error(y_test_c, y_pred_c)
rmse_c = np.sqrt(mse_c)
r2_c = r2_score(y_test_c, y_pred_c)

# Model tanpa clustering
features_no_cluster = ['type', 'country', 'release_year', 'rating']
X_no_cluster = df_cleaned[features_no_cluster]

X_train_nc, X_test_nc, y_train_nc, y_test_nc = train_test_split(X_no_cluster, y, test_size=0.2, random_state=42)

model_nc = LinearRegression()
model_nc.fit(X_train_nc, y_train_nc)
y_pred_nc = model_nc.predict(X_test_nc)

# Evaluasi model tanpa clustering
mae_nc = mean_absolute_error(y_test_nc, y_pred_nc)
mse_nc = mean_squared_error(y_test_nc, y_pred_nc)
rmse_nc = np.sqrt(mse_nc)
r2_nc = r2_score(y_test_nc, y_pred_nc)

# Menampilkan perbandingan hasil
print("\nðŸ“Š Perbandingan Model Dengan dan Tanpa Clustering:")
print(f"{'Metric':<25} {'Linear Regression + Clustering':<25} {'Linear Regression (No Cluster)':<25}")
print("-" * 80)
print(f"{'MAE':<25} {mae_c:.2f} {mae_nc:.2f}")
print(f"{'MSE':<25} {mse_c:.2f} {mse_nc:.2f}")
print(f"{'RMSE':<25} {rmse_c:.2f} {rmse_nc:.2f}")
print(f"{'RÂ² Score':<25} {r2_c:.4f} {r2_nc:.4f}")

# VISUALISASI PERBANDINGAN MODEL DENGAN DAN TANPA CLUSTERING
plt.figure(figsize=(10, 5))
models_compare = ['LR + Clustering', 'LR (No Cluster)']
r2_scores_compare = [r2_c, r2_nc]

plt.bar(models_compare, r2_scores_compare, color=['blue', 'red'])
plt.xlabel("Model")
plt.ylabel("RÂ² Score")
plt.title("Perbandingan RÂ² Score Model Dengan dan Tanpa Clustering")
plt.ylim(0, 1)
plt.show()